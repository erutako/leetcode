### 課題の言語化(できたら現実世界で同じ課題を再現する)
> 数字が書かれたカードが何枚か(nums)と、壁に書かれた一つの数字(target)がある。
2枚のカードを選んで書かれている数字を足し算すると壁に書かれた数字となるようなカードの番号を見つける。
そのようなカードの組み合わせは一つしか存在せず、同じカードを2回選ぶことはできない。

一旦カードに書かれた数字が0-100だと限定し考える。
0-100の数値に対応する10x10の表のようなカード置き場を用意する。
カードを順に見ていき、壁に書かれた数字-カードに書かれた数字の数の表のマスを見て、数字がなければいま見ているカードに書かれた数字のマスにそのカードが何番目に見たカードかメモする。
順に繰り返すと、どこかで壁に書かれた数字-カードに書かれた数字の数の表のマスを見たときに数字がメモされているときがくるはず。
そのときに、マスにメモされている数字と今見ているカードが何番目かの数字が求められている答え。

### 思考記録
課題の言語化でだいぶコードのイメージがついた。
とりあえず書いてみる。
ここまでで11分。
今回は値が見付からなかったときは`[-1, -1]`で返すことにする。

### 計算量
#### 時間計算量
O(N)でいける
#### 空間計算量
こちらもO(N)でいける

### コード
```Java
import java.util.Hashtable;
import java.util.Objects;

class Solution {
  public int[] twoSum(int[] nums, int target) {
    Hashtable<Integer, Integer> table = new Hashtable<>();
    for (int i = 0; i < nums.length; i++) {
      int requiredNum = target - nums[i];
      Integer requiredIdx = table.get(requiredNum);
      if (Objects.isNull(requiredIdx)) {
        table.put(nums[i], i);
      } else {
        return new int[]{i, requiredIdx.intValue()};
      }
    }
    return new int[]{-1, -1};
  }
}
```

### 感想(他の方のコードなどを読んで)
- 課題の言語化はハッシュテーブルありきで言語化したので、あまり意味はなかったかも？でも、ハッシュテーブルでやろうとしていることのイメージを具体化するうえでは良かった。
- 提出コードを書ききるまでに結局40分かかった。途中でランタイムエラーがでたり、ハッシュテーブルの実装を調べたりしていたので時間の測り方としては良くなかったかも。
- HashTableのinitialCapacityを増やして実行すると実効速度は早くならない一方で、メモリ使用量は増えるだけだった。意外。数値の範囲は割と大きいのに少しずつハッシュテーブルを大きくするほうが良いのか？実行時に与えられている数値にもよるか。
- HashTableはスレッドセーフだったり色々サポートしてくれる分HashMapよりも遅い？nullをサポートしたい、マルチスレッド環境で動かしたいというニーズがなければHashMapで良さそう。
- Objects.isNullを使っていたけど、containsKeyのほうがシンプル。
