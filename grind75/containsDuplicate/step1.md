### やろうとしていることを言語化してみる
数字が書かれたカードが何枚かある。
2枚以上のカードに書かれている数字があればOKとし、どのカードにも違う数字が書かれていればNGとする。
数字が書かれた表のようなカード置き場を紙に書く。
カードを順に取り出し、カードに書かれた数字のセルにカードを置く。
既にカードが置かれていればOKにする。
最後の1枚までOKにならなければNGにする。

### 思考記録
2枚以上を探す方針とどのカードも違うことを証明する方針の２つを思いつく。
O(N)ではいけそうな気配がする。
O(1)とO(logN)でいくのは難しそうな気がするし、O(N)は合格点な気がする。
HashMap使うと時間計算量O(N)はいけそう。
あとは空間計算量を節約する方法がもしかしたらあるかもしれないが、時間もないのでとりあえずHashMapで実装。
HashMapのキーは数字にすれば良いけど、バリューはどうしよう。値を保つ必要は今回ないけど、他のデータ型で表現する方法があまり思いつかない...
最初に10^5サイズの配列を作るとかはできるけど、HashMapよりもメモリ使いそう。

### 計算量
#### 時間計算量
O(N)
#### 空間計算量
O(N)

### コード
```Java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        boolean result = false;

        for (int num : nums) {
            if (map.containsKey(num)) {
                result = true;
                break;
            }

            map.put(num, 1);
        }

        return result;
    }
}
```
### かかった時間
14分

### 感想
- これが初見で解けたのは成長を感じた... Arrayに絞って解いている効果が出ていそう。
- なるほど、ユニークな値かどうかが今回のポイントなのでSetを使うとよいのか。確かに。
  - 今回はSetだと過不足ないデータ構造で、追加で登場回数とかを数えたい場合であればMapを使えばよかった。
  - 値をソートして持っておきたいかどうかなどもどのクラスを利用するかを考えるポイントになりそう。
- HashSetはスレッドセーフではないらしいので、例えば要素数が非常に大きくていくつかに分割してマルチスレッドで処理する場合は`Set s = Collections.synchronizedSet(new HashSet());`とかやる必要があるそう。
  -https://docs.oracle.com/javase/jp/8/docs/api/java/util/HashSet.html
- 